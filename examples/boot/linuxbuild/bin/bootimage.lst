
..\linuxbuild\bin/bootimage:     file format elf64-littleriscv


Disassembly of section .text:

0000000000010000 <_start>:
  .globl _start
  .globl exception_handler_c
  .globl interrupt_handler_c

_start:
  j reset_vector
   10000:	0380006f          	j	10038 <reset_vector>

0000000000010004 <trap_table>:
trap_table:
  j trap_entry
   10004:	1180006f          	j	1011c <trap_entry>
/* if mtvec is configured as a vectorized interrupt handlers */
  j bad_irq  # 1 Supervisor software interrupt
   10008:	02c0006f          	j	10034 <bad_irq>
  j bad_irq  # 2 Reserved
   1000c:	0280006f          	j	10034 <bad_irq>
  j bad_irq  # 3 Machine software interrupt
   10010:	0240006f          	j	10034 <bad_irq>
  j bad_irq  # 4 User timer interrupt
   10014:	0200006f          	j	10034 <bad_irq>
  j bad_irq  # 5 Supervisor timer interrupt
   10018:	01c0006f          	j	10034 <bad_irq>
  j bad_irq  # 6 Reserved
   1001c:	0180006f          	j	10034 <bad_irq>
  j bad_irq  # 7 Machine timer interrupt
   10020:	0140006f          	j	10034 <bad_irq>
  j bad_irq  # 8 User external interrupt
   10024:	0100006f          	j	10034 <bad_irq>
  j bad_irq  # 9 Supervisor external interrupt
   10028:	00c0006f          	j	10034 <bad_irq>
  j bad_irq  # 10 Reserved
   1002c:	0080006f          	j	10034 <bad_irq>
  j bad_irq  # 11 Machine external interrupt
   10030:	0040006f          	j	10034 <bad_irq>

0000000000010034 <bad_irq>:

bad_irq:
   j bad_irq
   10034:	0000006f          	j	10034 <bad_irq>

0000000000010038 <reset_vector>:

reset_vector:
  li  x1, 0
   10038:	00000093          	li	ra,0
  li  x2, 0
   1003c:	00000113          	li	sp,0
  li  x3, 0
   10040:	00000193          	li	gp,0
  li  x4, 0
   10044:	00000213          	li	tp,0
  li  x5, 0
   10048:	00000293          	li	t0,0
  li  x6, 0
   1004c:	00000313          	li	t1,0
  li  x7, 0
   10050:	00000393          	li	t2,0
  li  x8, 0
   10054:	00000413          	li	s0,0
  li  x9, 0
   10058:	00000493          	li	s1,0
  li  x10,0
   1005c:	00000513          	li	a0,0
  li  x11,0
   10060:	00000593          	li	a1,0
  li  x12,0
   10064:	00000613          	li	a2,0
  li  x13,0
   10068:	00000693          	li	a3,0
  li  x14,0
   1006c:	00000713          	li	a4,0
  li  x15,0
   10070:	00000793          	li	a5,0
  li  x16,0
   10074:	00000813          	li	a6,0
  li  x17,0
   10078:	00000893          	li	a7,0
  li  x18,0
   1007c:	00000913          	li	s2,0
  li  x19,0
   10080:	00000993          	li	s3,0
  li  x20,0
   10084:	00000a13          	li	s4,0
  li  x21,0
   10088:	00000a93          	li	s5,0
  li  x22,0
   1008c:	00000b13          	li	s6,0
  li  x23,0
   10090:	00000b93          	li	s7,0
  li  x24,0
   10094:	00000c13          	li	s8,0
  li  x25,0
   10098:	00000c93          	li	s9,0
  li  x26,0
   1009c:	00000d13          	li	s10,0
  li  x27,0
   100a0:	00000d93          	li	s11,0
  li  x28,0
   100a4:	00000e13          	li	t3,0
  li  x29,0
   100a8:	00000e93          	li	t4,0
  li  x30,0
   100ac:	00000f13          	li	t5,0
  li  x31,0
   100b0:	00000f93          	li	t6,0
  ##! csrrs - atomic read and set bit
  ##! csrc (pseudo asm instruction) - clear bit 
  ##! csrrc - atomic read and clear bit

  # Clear Previous mode (set U-mode), disable interrupt in U-mode
  li t0, 0x00001880   # MPP[12:11] = 0x0 MPIE[7]=0 (Previous to machine mode)
   100b4:	000022b7          	lui	t0,0x2
   100b8:	8802829b          	addiw	t0,t0,-1920
  csrc mstatus, t0    # run tests in user mode = 0, by clearing bits
   100bc:	3002b073          	csrc	mstatus,t0

  la t0, trap_table
   100c0:	00000297          	auipc	t0,0x0
   100c4:	f4428293          	addi	t0,t0,-188 # 10004 <trap_table>
  csrw mtvec, t0
   100c8:	30529073          	csrw	mtvec,t0
  li t0, 0x00000800
   100cc:	000012b7          	lui	t0,0x1
   100d0:	8002829b          	addiw	t0,t0,-2048
  csrs mie, t0       # Enable External irq (ftom PLIC) for M mode
   100d4:	3042a073          	csrs	mie,t0
  fmv.s.x f30,x0
  fmv.s.x f31,x0
#endif

  ##! get core id
  csrr a0, mhartid            # a0 <= MHARTID value
   100d8:	f1402573          	csrr	a0,mhartid
#define SRAM_SIZE_BYTES (1<<19)
#define STACK_PER_CORE_BYTES 4096
#define CFG_CPU_MAX 4

  #dedicated region to save cpu context on exception (not interrupt)
  li  sp, SRAM_BASE_ADDR+SRAM_SIZE_BYTES
   100dc:	08080137          	lui	sp,0x8080
  addi sp,sp,-256
   100e0:	f0010113          	addi	sp,sp,-256 # 807ff00 <_end+0x806f514>
  csrw 0x7b3, sp          # save dedicated stack region into dscratch1 register to run riscv-tests
   100e4:	7b311073          	csrw	0x7b3,sp

  # Initialze stack pointer for each cpu
  li  a1, (CFG_CPU_MAX - 1)
   100e8:	00300593          	li	a1,3
  sub a0, a1, a0                  # (CFG_CPU_MAX - 1 - hartid)
   100ec:	40a58533          	sub	a0,a1,a0
  li  a1, STACK_PER_CORE_BYTES
   100f0:	000015b7          	lui	a1,0x1
  mul a0, a0, a1
   100f4:	02b50533          	mul	a0,a0,a1
  sub sp, sp, a0
   100f8:	40a10133          	sub	sp,sp,a0

  # copy image 64 KB
  csrr a0, mhartid            # a0 <= MHARTID value
   100fc:	f1402573          	csrr	a0,mhartid
  beqz a0, init0
   10100:	00050663          	beqz	a0,1010c <init0>
  wfi
   10104:	10500073          	wfi
  j end_init0
   10108:	0080006f          	j	10110 <end_init0>

000000000001010c <init0>:
init0:
  # HW Initialization is run only on Core[0]
  jal _init
   1010c:	3a0000ef          	jal	ra,104ac <_init>

0000000000010110 <end_init0>:
end_init0:

  ##! jump to entry point in SRAM = 0x08000000
  ##!     'meps' - Machine Exception Program Coutner
  li  t0, SRAM_BASE_ADDR
   10110:	080002b7          	lui	t0,0x8000
  csrw mepc, t0
   10114:	34129073          	csrw	mepc,t0
  mret
   10118:	30200073          	mret

000000000001011c <trap_entry>:

trap_entry:
  ## was it an interrupt or an exception?
  csrw mscratch, t5;
   1011c:	340f1073          	csrw	mscratch,t5
  csrr t5, mcause;
   10120:	34202f73          	csrr	t5,mcause
  bgez t5, handle_exception;
   10124:	100f5e63          	bgez	t5,10240 <handle_exception>

0000000000010128 <interrupt_entry>:

interrupt_entry:
  add sp, sp, -COOP_REG_FRAME
   10128:	f0810113          	addi	sp,sp,-248
  _save_context(sp)
   1012c:	00113023          	sd	ra,0(sp)
   10130:	00813423          	sd	s0,8(sp)
   10134:	00913823          	sd	s1,16(sp)
   10138:	01213c23          	sd	s2,24(sp)
   1013c:	03313023          	sd	s3,32(sp)
   10140:	03413423          	sd	s4,40(sp)
   10144:	03513823          	sd	s5,48(sp)
   10148:	03613c23          	sd	s6,56(sp)
   1014c:	05713023          	sd	s7,64(sp)
   10150:	05813423          	sd	s8,72(sp)
   10154:	05913823          	sd	s9,80(sp)
   10158:	05a13c23          	sd	s10,88(sp)
   1015c:	07b13023          	sd	s11,96(sp)
   10160:	06213423          	sd	sp,104(sp)
   10164:	07013c23          	sd	a6,120(sp)
   10168:	09113023          	sd	a7,128(sp)
   1016c:	08a13423          	sd	a0,136(sp)
   10170:	08b13823          	sd	a1,144(sp)
   10174:	08c13c23          	sd	a2,152(sp)
   10178:	0ad13023          	sd	a3,160(sp)
   1017c:	0ae13423          	sd	a4,168(sp)
   10180:	0af13823          	sd	a5,176(sp)
   10184:	0b013c23          	sd	a6,184(sp)
   10188:	0d113023          	sd	a7,192(sp)
   1018c:	0c513423          	sd	t0,200(sp)
   10190:	0c613823          	sd	t1,208(sp)
   10194:	0c713c23          	sd	t2,216(sp)
   10198:	0fc13023          	sd	t3,224(sp)
   1019c:	0fd13423          	sd	t4,232(sp)
   101a0:	0e313823          	sd	gp,240(sp)
  ##       long handle_trap(long cause, long epc, long long regs[32])
  ##             a0 = argument 1: cause
  ##             a1 = argument 2: mepc
  ##             a2 = argument 3: pointer on stack
  ## @return     a0 New instruction pointer offset
  csrr a0, mcause
   101a4:	34202573          	csrr	a0,mcause
  csrr a1, mepc
   101a8:	341025f3          	csrr	a1,mepc
  mv a2, sp
   101ac:	00010613          	mv	a2,sp
  jal interrupt_handler_c
   101b0:	58e000ef          	jal	ra,1073e <interrupt_handler_c>

  # tp-offset in the context array is used to save mepc value. An it may be
  # modified by isr handler during preemtive task switching.
  ld t5,COOP_REG_TP(sp)
   101b4:	07013f03          	ld	t5,112(sp)
  csrw mepc,t5
   101b8:	341f1073          	csrw	mepc,t5
  _restore_context(sp)
   101bc:	00013083          	ld	ra,0(sp)
   101c0:	00813403          	ld	s0,8(sp)
   101c4:	01013483          	ld	s1,16(sp)
   101c8:	01813903          	ld	s2,24(sp)
   101cc:	02013983          	ld	s3,32(sp)
   101d0:	02813a03          	ld	s4,40(sp)
   101d4:	03013a83          	ld	s5,48(sp)
   101d8:	03813b03          	ld	s6,56(sp)
   101dc:	04013b83          	ld	s7,64(sp)
   101e0:	04813c03          	ld	s8,72(sp)
   101e4:	05013c83          	ld	s9,80(sp)
   101e8:	05813d03          	ld	s10,88(sp)
   101ec:	06013d83          	ld	s11,96(sp)
   101f0:	06813103          	ld	sp,104(sp)
   101f4:	07813803          	ld	a6,120(sp)
   101f8:	08013883          	ld	a7,128(sp)
   101fc:	08813503          	ld	a0,136(sp)
   10200:	09013583          	ld	a1,144(sp)
   10204:	09813603          	ld	a2,152(sp)
   10208:	0a013683          	ld	a3,160(sp)
   1020c:	0a813703          	ld	a4,168(sp)
   10210:	0b013783          	ld	a5,176(sp)
   10214:	0b813803          	ld	a6,184(sp)
   10218:	0c013883          	ld	a7,192(sp)
   1021c:	0c813283          	ld	t0,200(sp)
   10220:	0d013303          	ld	t1,208(sp)
   10224:	0d813383          	ld	t2,216(sp)
   10228:	0e013e03          	ld	t3,224(sp)
   1022c:	0e813e83          	ld	t4,232(sp)
   10230:	0f013183          	ld	gp,240(sp)
  add sp, sp, COOP_REG_FRAME
   10234:	0f810113          	addi	sp,sp,248
  csrr t5,mscratch
   10238:	34002f73          	csrr	t5,mscratch
  mret
   1023c:	30200073          	mret

0000000000010240 <handle_exception>:


handle_exception:
  # All registers are invalid after riscv-tests finished!!
  csrr sp, 0x7b3          # restore dedicated stack region from dscratch1 dregister
   10240:	7b302173          	csrr	sp,0x7b3
  jal exception_handler_c
   10244:	3de000ef          	jal	ra,10622 <exception_handler_c>
  mret
   10248:	30200073          	mret
   1024c:	0000                	unimp
   1024e:	0000                	unimp
	...

0000000000010252 <fw_get_cpuid>:
#include "axi_maps.h"
#include "encoding.h"

static const int FW_IMAGE_SIZE_BYTES = 1 << 18;

int fw_get_cpuid() {
   10252:	1101                	addi	sp,sp,-32
   10254:	ec22                	sd	s0,24(sp)
   10256:	1000                	addi	s0,sp,32
    int ret;
    asm("csrr %0, mhartid" : "=r" (ret));
   10258:	f14027f3          	csrr	a5,mhartid
   1025c:	fef42623          	sw	a5,-20(s0)
    return ret;
   10260:	fec42783          	lw	a5,-20(s0)
}
   10264:	853e                	mv	a0,a5
   10266:	6462                	ld	s0,24(sp)
   10268:	6105                	addi	sp,sp,32
   1026a:	8082                	ret

000000000001026c <led_set>:

void led_set(int output) {
   1026c:	1101                	addi	sp,sp,-32
   1026e:	ec22                	sd	s0,24(sp)
   10270:	1000                	addi	s0,sp,32
   10272:	87aa                	mv	a5,a0
   10274:	fef42623          	sw	a5,-20(s0)
    // [3:0] DIP pins
    ((gpio_map *)ADDR_BUS0_XSLV_GPIO)->ouser = (output << 4);
   10278:	fec42783          	lw	a5,-20(s0)
   1027c:	0047979b          	slliw	a5,a5,0x4
   10280:	0007871b          	sext.w	a4,a5
   10284:	100607b7          	lui	a5,0x10060
   10288:	2701                	sext.w	a4,a4
   1028a:	c798                	sw	a4,8(a5)
}
   1028c:	0001                	nop
   1028e:	6462                	ld	s0,24(sp)
   10290:	6105                	addi	sp,sp,32
   10292:	8082                	ret

0000000000010294 <get_dip>:

int get_dip(int idx) {
   10294:	7179                	addi	sp,sp,-48
   10296:	f422                	sd	s0,40(sp)
   10298:	1800                	addi	s0,sp,48
   1029a:	87aa                	mv	a5,a0
   1029c:	fcf42e23          	sw	a5,-36(s0)
    // [3:0] DIP pins
    int dip = ((gpio_map *)ADDR_BUS0_XSLV_GPIO)->iuser >> idx;
   102a0:	100607b7          	lui	a5,0x10060
   102a4:	43dc                	lw	a5,4(a5)
   102a6:	0007871b          	sext.w	a4,a5
   102aa:	fdc42783          	lw	a5,-36(s0)
   102ae:	00f757bb          	srlw	a5,a4,a5
   102b2:	2781                	sext.w	a5,a5
   102b4:	fef42623          	sw	a5,-20(s0)
    return dip & 1;
   102b8:	fec42783          	lw	a5,-20(s0)
   102bc:	8b85                	andi	a5,a5,1
   102be:	2781                	sext.w	a5,a5
}
   102c0:	853e                	mv	a0,a5
   102c2:	7422                	ld	s0,40(sp)
   102c4:	6145                	addi	sp,sp,48
   102c6:	8082                	ret

00000000000102c8 <print_uart>:

void print_uart(const char *buf, int sz) {
   102c8:	7139                	addi	sp,sp,-64
   102ca:	fc22                	sd	s0,56(sp)
   102cc:	0080                	addi	s0,sp,64
   102ce:	fca43423          	sd	a0,-56(s0)
   102d2:	87ae                	mv	a5,a1
   102d4:	fcf42223          	sw	a5,-60(s0)
    uart_map *uart = (uart_map *)ADDR_BUS0_XSLV_UART0;
   102d8:	100107b7          	lui	a5,0x10010
   102dc:	fef43023          	sd	a5,-32(s0)
    uart_txdata_type txdata;
    for (int i = 0; i < sz; i++) {
   102e0:	fe042623          	sw	zero,-20(s0)
   102e4:	a83d                	j	10322 <print_uart+0x5a>
        do {
            txdata.v = uart->txdata;
   102e6:	fe043783          	ld	a5,-32(s0)
   102ea:	439c                	lw	a5,0(a5)
   102ec:	2781                	sext.w	a5,a5
   102ee:	fcf42c23          	sw	a5,-40(s0)
        } while (txdata.b.full);
   102f2:	fdb44783          	lbu	a5,-37(s0)
   102f6:	f807f793          	andi	a5,a5,-128
   102fa:	0ff7f793          	andi	a5,a5,255
   102fe:	f7e5                	bnez	a5,102e6 <print_uart+0x1e>
        uart->txdata = buf[i];
   10300:	fec42783          	lw	a5,-20(s0)
   10304:	fc843703          	ld	a4,-56(s0)
   10308:	97ba                	add	a5,a5,a4
   1030a:	0007c783          	lbu	a5,0(a5) # 10010000 <_end+0xffff614>
   1030e:	0007871b          	sext.w	a4,a5
   10312:	fe043783          	ld	a5,-32(s0)
   10316:	c398                	sw	a4,0(a5)
    for (int i = 0; i < sz; i++) {
   10318:	fec42783          	lw	a5,-20(s0)
   1031c:	2785                	addiw	a5,a5,1
   1031e:	fef42623          	sw	a5,-20(s0)
   10322:	fec42703          	lw	a4,-20(s0)
   10326:	fc442783          	lw	a5,-60(s0)
   1032a:	2701                	sext.w	a4,a4
   1032c:	2781                	sext.w	a5,a5
   1032e:	faf74ce3          	blt	a4,a5,102e6 <print_uart+0x1e>
    }
}
   10332:	0001                	nop
   10334:	7462                	ld	s0,56(sp)
   10336:	6121                	addi	sp,sp,64
   10338:	8082                	ret

000000000001033a <print_uart_hex>:

void print_uart_hex(long val) {
   1033a:	7139                	addi	sp,sp,-64
   1033c:	fc22                	sd	s0,56(sp)
   1033e:	0080                	addi	s0,sp,64
   10340:	fca43423          	sd	a0,-56(s0)
    unsigned char t, s;
    uart_map *uart = (uart_map *)ADDR_BUS0_XSLV_UART0;
   10344:	100107b7          	lui	a5,0x10010
   10348:	fef43023          	sd	a5,-32(s0)
    uart_txdata_type txdata;
    for (int i = 0; i < 16; i++) {
   1034c:	fe042423          	sw	zero,-24(s0)
   10350:	a041                	j	103d0 <print_uart_hex+0x96>
        do {
            txdata.v = uart->txdata;
   10352:	fe043783          	ld	a5,-32(s0)
   10356:	439c                	lw	a5,0(a5)
   10358:	2781                	sext.w	a5,a5
   1035a:	fcf42c23          	sw	a5,-40(s0)
        } while (txdata.b.full);;
   1035e:	fdb44783          	lbu	a5,-37(s0)
   10362:	f807f793          	andi	a5,a5,-128
   10366:	0ff7f793          	andi	a5,a5,255
   1036a:	f7e5                	bnez	a5,10352 <print_uart_hex+0x18>
        
        t = (unsigned char)((val >> ((15 - i) * 4)) & 0xf);
   1036c:	473d                	li	a4,15
   1036e:	fe842783          	lw	a5,-24(s0)
   10372:	40f707bb          	subw	a5,a4,a5
   10376:	2781                	sext.w	a5,a5
   10378:	0027979b          	slliw	a5,a5,0x2
   1037c:	2781                	sext.w	a5,a5
   1037e:	fc843703          	ld	a4,-56(s0)
   10382:	40f757b3          	sra	a5,a4,a5
   10386:	0ff7f793          	andi	a5,a5,255
   1038a:	8bbd                	andi	a5,a5,15
   1038c:	fcf40fa3          	sb	a5,-33(s0)
        if (t < 10) {
   10390:	fdf44783          	lbu	a5,-33(s0)
   10394:	0ff7f713          	andi	a4,a5,255
   10398:	47a5                	li	a5,9
   1039a:	00e7e963          	bltu	a5,a4,103ac <print_uart_hex+0x72>
            s = t + '0';
   1039e:	fdf44783          	lbu	a5,-33(s0)
   103a2:	0307879b          	addiw	a5,a5,48
   103a6:	fef407a3          	sb	a5,-17(s0)
   103aa:	a039                	j	103b8 <print_uart_hex+0x7e>
        } else {
            s = (t - 10) + 'a';
   103ac:	fdf44783          	lbu	a5,-33(s0)
   103b0:	0577879b          	addiw	a5,a5,87
   103b4:	fef407a3          	sb	a5,-17(s0)
        }
        uart->txdata = s;
   103b8:	fef44783          	lbu	a5,-17(s0)
   103bc:	0007871b          	sext.w	a4,a5
   103c0:	fe043783          	ld	a5,-32(s0)
   103c4:	c398                	sw	a4,0(a5)
    for (int i = 0; i < 16; i++) {
   103c6:	fe842783          	lw	a5,-24(s0)
   103ca:	2785                	addiw	a5,a5,1
   103cc:	fef42423          	sw	a5,-24(s0)
   103d0:	fe842783          	lw	a5,-24(s0)
   103d4:	0007871b          	sext.w	a4,a5
   103d8:	47bd                	li	a5,15
   103da:	f6e7dce3          	ble	a4,a5,10352 <print_uart_hex+0x18>
    }
}
   103de:	0001                	nop
   103e0:	7462                	ld	s0,56(sp)
   103e2:	6121                	addi	sp,sp,64
   103e4:	8082                	ret

00000000000103e6 <copy_image>:

void copy_image() { 
   103e6:	7139                	addi	sp,sp,-64
   103e8:	fc06                	sd	ra,56(sp)
   103ea:	f822                	sd	s0,48(sp)
   103ec:	0080                	addi	s0,sp,64
    uint32_t tech;
    uint64_t *fwrom = (uint64_t *)ADDR_BUS0_XSLV_FWIMAGE;
   103ee:	001007b7          	lui	a5,0x100
   103f2:	fef43423          	sd	a5,-24(s0)
    uint64_t *flash = (uint64_t *)ADDR_BUS0_XSLV_EXTFLASH;
   103f6:	002007b7          	lui	a5,0x200
   103fa:	fef43023          	sd	a5,-32(s0)
    uint64_t *sram = (uint64_t *)ADDR_BUS0_XSLV_SRAM;
   103fe:	080007b7          	lui	a5,0x8000
   10402:	fcf43c23          	sd	a5,-40(s0)
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   10406:	100ff7b7          	lui	a5,0x100ff
   1040a:	fcf43823          	sd	a5,-48(s0)

    /** 
     * Speed-up RTL simulation by skipping coping stage.
     * Or skip this stage to avoid rewritting of externally loaded image.
     */
    tech = pnp->tech & 0xFF;
   1040e:	fd043783          	ld	a5,-48(s0)
   10412:	479c                	lw	a5,8(a5)
   10414:	0ff7f793          	andi	a5,a5,255
   10418:	fcf42623          	sw	a5,-52(s0)

    if (tech != TECH_INFERRED && pnp->fwid == 0) {
   1041c:	fcc42783          	lw	a5,-52(s0)
   10420:	2781                	sext.w	a5,a5
   10422:	c3b5                	beqz	a5,10486 <copy_image+0xa0>
   10424:	fd043783          	ld	a5,-48(s0)
   10428:	43dc                	lw	a5,4(a5)
   1042a:	efb1                	bnez	a5,10486 <copy_image+0xa0>
        if (get_dip(0) == 1) {
   1042c:	4501                	li	a0,0
   1042e:	00000097          	auipc	ra,0x0
   10432:	e66080e7          	jalr	-410(ra) # 10294 <get_dip>
   10436:	87aa                	mv	a5,a0
   10438:	873e                	mv	a4,a5
   1043a:	4785                	li	a5,1
   1043c:	02f71463          	bne	a4,a5,10464 <copy_image+0x7e>
            print_uart("Coping FLASH\r\n", 14);
   10440:	45b9                	li	a1,14
   10442:	67c5                	lui	a5,0x11
   10444:	87078513          	addi	a0,a5,-1936 # 10870 <memcpy+0xc4>
   10448:	e81ff0ef          	jal	ra,102c8 <print_uart>
            memcpy(sram, flash, FW_IMAGE_SIZE_BYTES);
   1044c:	000407b7          	lui	a5,0x40
   10450:	863e                	mv	a2,a5
   10452:	fe043583          	ld	a1,-32(s0)
   10456:	fd843503          	ld	a0,-40(s0)
   1045a:	00000097          	auipc	ra,0x0
   1045e:	352080e7          	jalr	850(ra) # 107ac <memcpy>
   10462:	a015                	j	10486 <copy_image+0xa0>
        } else {
            print_uart("Coping FWIMAGE\r\n", 16);
   10464:	45c1                	li	a1,16
   10466:	67c5                	lui	a5,0x11
   10468:	88078513          	addi	a0,a5,-1920 # 10880 <memcpy+0xd4>
   1046c:	e5dff0ef          	jal	ra,102c8 <print_uart>
            memcpy(sram, fwrom, FW_IMAGE_SIZE_BYTES);
   10470:	000407b7          	lui	a5,0x40
   10474:	863e                	mv	a2,a5
   10476:	fe843583          	ld	a1,-24(s0)
   1047a:	fd843503          	ld	a0,-40(s0)
   1047e:	00000097          	auipc	ra,0x0
   10482:	32e080e7          	jalr	814(ra) # 107ac <memcpy>
        }
    }
    // Write Firmware ID to avoid copy image after soft-reset.
    pnp->fwid = 0x20211123;
   10486:	fd043783          	ld	a5,-48(s0)
   1048a:	20211737          	lui	a4,0x20211
   1048e:	1237071b          	addiw	a4,a4,291
   10492:	c3d8                	sw	a4,4(a5)
}
   10494:	0001                	nop
   10496:	70e2                	ld	ra,56(sp)
   10498:	7442                	ld	s0,48(sp)
   1049a:	6121                	addi	sp,sp,64
   1049c:	8082                	ret

000000000001049e <timestamp_output>:

/** This function will be used during video recording to show
 how tochange npc register value on core[1] while core[0] is running
 Zephyr OS
*/
void timestamp_output() {
   1049e:	1141                	addi	sp,sp,-16
   104a0:	e422                	sd	s0,8(sp)
   104a2:	0800                	addi	s0,sp,16
            print_uart("HIGHCNT: ", 9);
            print_uart_hex(start);
            print_uart("\r\n", 2);
        }
    }*/
}
   104a4:	0001                	nop
   104a6:	6422                	ld	s0,8(sp)
   104a8:	0141                	addi	sp,sp,16
   104aa:	8082                	ret

00000000000104ac <_init>:

void _init() {
   104ac:	7139                	addi	sp,sp,-64
   104ae:	fc06                	sd	ra,56(sp)
   104b0:	f822                	sd	s0,48(sp)
   104b2:	0080                	addi	s0,sp,64
    uint32_t tech;
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   104b4:	100ff7b7          	lui	a5,0x100ff
   104b8:	fef43423          	sd	a5,-24(s0)
    uart_map *uart = (uart_map *)ADDR_BUS0_XSLV_UART0;
   104bc:	100107b7          	lui	a5,0x10010
   104c0:	fef43023          	sd	a5,-32(s0)
    gpio_map *gpio = (gpio_map *)ADDR_BUS0_XSLV_GPIO;
   104c4:	100607b7          	lui	a5,0x10060
   104c8:	fcf43c23          	sd	a5,-40(s0)
  
    // mask all interrupts in interrupt controller to avoid
    // unpredictable behaviour after elf-file reloading via debug port.
    uint64_t t1 = 0x00000008;
   104cc:	47a1                	li	a5,8
   104ce:	fcf43823          	sd	a5,-48(s0)
    asm("csrc mstatus, %0" : :"r"(t1));  // clear mie
   104d2:	fd043783          	ld	a5,-48(s0)
   104d6:	3007b073          	csrc	mstatus,a5
    t1 = 0x00000800;
   104da:	6785                	lui	a5,0x1
   104dc:	80078793          	addi	a5,a5,-2048 # 800 <_start-0xf800>
   104e0:	fcf43823          	sd	a5,-48(s0)
    asm("csrc mie, %0" : :"r"(t1));  // disable external irq from PLIC
   104e4:	fd043783          	ld	a5,-48(s0)
   104e8:	3047b073          	csrc	mie,a5

    // Half period of the uart = Fbus / 115200 / 2 = 70 MHz / 115200 / 2:
    uart->scaler = SYS_HZ / 115200 / 2;  // 40 MHz
   104ec:	fe043783          	ld	a5,-32(s0)
   104f0:	0ad00713          	li	a4,173
   104f4:	cf98                	sw	a4,24(a5)

    gpio->direction = 0xF;  // [3:0] input DIP; [11:4] output LEDs
   104f6:	fd843783          	ld	a5,-40(s0)
   104fa:	473d                	li	a4,15
   104fc:	c398                	sw	a4,0(a5)

    led_set(0x01);
   104fe:	4505                	li	a0,1
   10500:	d6dff0ef          	jal	ra,1026c <led_set>
    print_uart("Boot . . .", 10);
   10504:	45a9                	li	a1,10
   10506:	67c5                	lui	a5,0x11
   10508:	89878513          	addi	a0,a5,-1896 # 10898 <memcpy+0xec>
   1050c:	dbdff0ef          	jal	ra,102c8 <print_uart>
    led_set(0x02);
   10510:	4509                	li	a0,2
   10512:	d5bff0ef          	jal	ra,1026c <led_set>

    copy_image();
   10516:	ed1ff0ef          	jal	ra,103e6 <copy_image>
    led_set(0x03);
   1051a:	450d                	li	a0,3
   1051c:	d51ff0ef          	jal	ra,1026c <led_set>
    print_uart("OK\r\n", 4);
   10520:	4591                	li	a1,4
   10522:	67c5                	lui	a5,0x11
   10524:	8a878513          	addi	a0,a5,-1880 # 108a8 <memcpy+0xfc>
   10528:	da1ff0ef          	jal	ra,102c8 <print_uart>

    tech = (pnp->tech >> 24) & 0xff;
   1052c:	fe843783          	ld	a5,-24(s0)
   10530:	479c                	lw	a5,8(a5)
   10532:	0187d79b          	srliw	a5,a5,0x18
   10536:	fcf42623          	sw	a5,-52(s0)
    led_set(tech);
   1053a:	fcc42783          	lw	a5,-52(s0)
   1053e:	853e                	mv	a0,a5
   10540:	d2dff0ef          	jal	ra,1026c <led_set>
    led_set(0x04);
   10544:	4511                	li	a0,4
   10546:	d27ff0ef          	jal	ra,1026c <led_set>
}
   1054a:	0001                	nop
   1054c:	70e2                	ld	ra,56(sp)
   1054e:	7442                	ld	s0,48(sp)
   10550:	6121                	addi	sp,sp,64
   10552:	8082                	ret

0000000000010554 <main>:

/** Not used actually */
int main() {
   10554:	1141                	addi	sp,sp,-16
   10556:	e422                	sd	s0,8(sp)
   10558:	0800                	addi	s0,sp,16
    while (1) {}
   1055a:	a001                	j	1055a <main+0x6>
	...

000000000001055e <get_mcause>:

extern void print_uart(const char *buf, int sz);
extern void print_uart_hex(long val);
extern void led_set(int output);

int get_mcause() {
   1055e:	1101                	addi	sp,sp,-32
   10560:	ec22                	sd	s0,24(sp)
   10562:	1000                	addi	s0,sp,32
    int ret;
    asm("csrr %0, mcause" : "=r" (ret));
   10564:	342027f3          	csrr	a5,mcause
   10568:	fef42623          	sw	a5,-20(s0)
    return ret;
   1056c:	fec42783          	lw	a5,-20(s0)
}
   10570:	853e                	mv	a0,a5
   10572:	6462                	ld	s0,24(sp)
   10574:	6105                	addi	sp,sp,32
   10576:	8082                	ret

0000000000010578 <get_mepc>:

int get_mepc() {
   10578:	1101                	addi	sp,sp,-32
   1057a:	ec22                	sd	s0,24(sp)
   1057c:	1000                	addi	s0,sp,32
    int ret;
    asm("csrr %0, mepc" : "=r" (ret));
   1057e:	341027f3          	csrr	a5,mepc
   10582:	fef42623          	sw	a5,-20(s0)
    return ret;
   10586:	fec42783          	lw	a5,-20(s0)
}
   1058a:	853e                	mv	a0,a5
   1058c:	6462                	ld	s0,24(sp)
   1058e:	6105                	addi	sp,sp,32
   10590:	8082                	ret

0000000000010592 <env_call>:


void env_call(long long test_id) {
   10592:	7179                	addi	sp,sp,-48
   10594:	f406                	sd	ra,40(sp)
   10596:	f022                	sd	s0,32(sp)
   10598:	1800                	addi	s0,sp,48
   1059a:	fca43c23          	sd	a0,-40(s0)
    if (test_id != 0) {
   1059e:	fd843783          	ld	a5,-40(s0)
   105a2:	c7bd                	beqz	a5,10610 <env_call+0x7e>
        int mbadaddr;
        print_uart("TEST_FAILED\r\n", 13);
   105a4:	45b5                	li	a1,13
   105a6:	67c5                	lui	a5,0x11
   105a8:	8b078513          	addi	a0,a5,-1872 # 108b0 <memcpy+0x104>
   105ac:	00000097          	auipc	ra,0x0
   105b0:	d1c080e7          	jalr	-740(ra) # 102c8 <print_uart>
        print_uart("a0=", 3);
   105b4:	458d                	li	a1,3
   105b6:	67c5                	lui	a5,0x11
   105b8:	8c078513          	addi	a0,a5,-1856 # 108c0 <memcpy+0x114>
   105bc:	00000097          	auipc	ra,0x0
   105c0:	d0c080e7          	jalr	-756(ra) # 102c8 <print_uart>
        print_uart_hex(test_id);
   105c4:	fd843503          	ld	a0,-40(s0)
   105c8:	d73ff0ef          	jal	ra,1033a <print_uart_hex>
        print_uart("\r\n", 2);
   105cc:	4589                	li	a1,2
   105ce:	67c5                	lui	a5,0x11
   105d0:	8c878513          	addi	a0,a5,-1848 # 108c8 <memcpy+0x11c>
   105d4:	00000097          	auipc	ra,0x0
   105d8:	cf4080e7          	jalr	-780(ra) # 102c8 <print_uart>

        asm("csrr %0, mbadaddr" : "=r" (mbadaddr));
   105dc:	343027f3          	csrr	a5,mbadaddr
   105e0:	fef42623          	sw	a5,-20(s0)
        print_uart("mbadaddr=", 9);
   105e4:	45a5                	li	a1,9
   105e6:	67c5                	lui	a5,0x11
   105e8:	8d078513          	addi	a0,a5,-1840 # 108d0 <memcpy+0x124>
   105ec:	00000097          	auipc	ra,0x0
   105f0:	cdc080e7          	jalr	-804(ra) # 102c8 <print_uart>
        print_uart_hex(mbadaddr);
   105f4:	fec42783          	lw	a5,-20(s0)
   105f8:	853e                	mv	a0,a5
   105fa:	d41ff0ef          	jal	ra,1033a <print_uart_hex>
        print_uart("\r\n", 2);
   105fe:	4589                	li	a1,2
   10600:	67c5                	lui	a5,0x11
   10602:	8c878513          	addi	a0,a5,-1848 # 108c8 <memcpy+0x11c>
   10606:	00000097          	auipc	ra,0x0
   1060a:	cc2080e7          	jalr	-830(ra) # 102c8 <print_uart>
   1060e:	a809                	j	10620 <env_call+0x8e>
    } else {
        print_uart("TEST_PASSED\r\n", 13);
   10610:	45b5                	li	a1,13
   10612:	67c5                	lui	a5,0x11
   10614:	8e078513          	addi	a0,a5,-1824 # 108e0 <memcpy+0x134>
   10618:	00000097          	auipc	ra,0x0
   1061c:	cb0080e7          	jalr	-848(ra) # 102c8 <print_uart>
    }
    while (1) {}
   10620:	a001                	j	10620 <env_call+0x8e>

0000000000010622 <exception_handler_c>:
}

void exception_handler_c(long long arg) {
   10622:	7179                	addi	sp,sp,-48
   10624:	f406                	sd	ra,40(sp)
   10626:	f022                	sd	s0,32(sp)
   10628:	1800                	addi	s0,sp,48
   1062a:	fca43c23          	sd	a0,-40(s0)
    int mcause = get_mcause();
   1062e:	00000097          	auipc	ra,0x0
   10632:	f30080e7          	jalr	-208(ra) # 1055e <get_mcause>
   10636:	87aa                	mv	a5,a0
   10638:	fef42623          	sw	a5,-20(s0)

    switch (mcause) {
   1063c:	fec42783          	lw	a5,-20(s0)
   10640:	37e1                	addiw	a5,a5,-8
   10642:	0007871b          	sext.w	a4,a5
   10646:	4785                	li	a5,1
   10648:	00e7e963          	bltu	a5,a4,1065a <exception_handler_c+0x38>
    case 8:  // user env. call
    case 9:  // supervisor env. call
        env_call(arg);
   1064c:	fd843503          	ld	a0,-40(s0)
   10650:	00000097          	auipc	ra,0x0
   10654:	f42080e7          	jalr	-190(ra) # 10592 <env_call>
        return;
   10658:	a0b9                	j	106a6 <exception_handler_c+0x84>
    default:;
    }

    print_uart("mcause:", 7);
   1065a:	459d                	li	a1,7
   1065c:	67c5                	lui	a5,0x11
   1065e:	8f078513          	addi	a0,a5,-1808 # 108f0 <memcpy+0x144>
   10662:	c67ff0ef          	jal	ra,102c8 <print_uart>
    print_uart_hex(mcause);
   10666:	fec42783          	lw	a5,-20(s0)
   1066a:	853e                	mv	a0,a5
   1066c:	00000097          	auipc	ra,0x0
   10670:	cce080e7          	jalr	-818(ra) # 1033a <print_uart_hex>
    print_uart(",mepc:", 6);
   10674:	4599                	li	a1,6
   10676:	67c5                	lui	a5,0x11
   10678:	8f878513          	addi	a0,a5,-1800 # 108f8 <memcpy+0x14c>
   1067c:	c4dff0ef          	jal	ra,102c8 <print_uart>
    print_uart_hex(get_mepc());
   10680:	ef9ff0ef          	jal	ra,10578 <get_mepc>
   10684:	87aa                	mv	a5,a0
   10686:	853e                	mv	a0,a5
   10688:	00000097          	auipc	ra,0x0
   1068c:	cb2080e7          	jalr	-846(ra) # 1033a <print_uart_hex>
    print_uart("\r\n", 2);
   10690:	4589                	li	a1,2
   10692:	67c5                	lui	a5,0x11
   10694:	8c878513          	addi	a0,a5,-1848 # 108c8 <memcpy+0x11c>
   10698:	c31ff0ef          	jal	ra,102c8 <print_uart>

    /// Exception trap
    led_set(0xF0);
   1069c:	0f000513          	li	a0,240
   106a0:	bcdff0ef          	jal	ra,1026c <led_set>
    while (1) {}
   106a4:	a001                	j	106a4 <exception_handler_c+0x82>
}
   106a6:	70a2                	ld	ra,40(sp)
   106a8:	7402                	ld	s0,32(sp)
   106aa:	6145                	addi	sp,sp,48
   106ac:	8082                	ret

00000000000106ae <fatal_error>:

/** Fatal Error Handler can be used to transmit dump image
 *  or trigger watchdog
 */
void fatal_error() {
   106ae:	1141                	addi	sp,sp,-16
   106b0:	e406                	sd	ra,8(sp)
   106b2:	e022                	sd	s0,0(sp)
   106b4:	0800                	addi	s0,sp,16
    led_set(0xF0);
   106b6:	0f000513          	li	a0,240
   106ba:	00000097          	auipc	ra,0x0
   106be:	bb2080e7          	jalr	-1102(ra) # 1026c <led_set>
    print_uart("fatal_error()\r\n", 15);
   106c2:	45bd                	li	a1,15
   106c4:	67c5                	lui	a5,0x11
   106c6:	90078513          	addi	a0,a5,-1792 # 10900 <memcpy+0x154>
   106ca:	00000097          	auipc	ra,0x0
   106ce:	bfe080e7          	jalr	-1026(ra) # 102c8 <print_uart>
    while (1) {}
   106d2:	a001                	j	106d2 <fatal_error+0x24>

00000000000106d4 <plic_claim>:
}


uint32_t plic_claim(int ctxid) {
   106d4:	7179                	addi	sp,sp,-48
   106d6:	f422                	sd	s0,40(sp)
   106d8:	1800                	addi	s0,sp,48
   106da:	87aa                	mv	a5,a0
   106dc:	fcf42e23          	sw	a5,-36(s0)
    plic_map *p = (plic_map *)ADDR_BUS0_XSLV_PLIC;
   106e0:	0c0007b7          	lui	a5,0xc000
   106e4:	fef43423          	sd	a5,-24(s0)
    return p->ctx_prio[ctxid].claim_complete;
   106e8:	fe843703          	ld	a4,-24(s0)
   106ec:	fdc42783          	lw	a5,-36(s0)
   106f0:	20078793          	addi	a5,a5,512 # c000200 <_end+0xbfef814>
   106f4:	07b2                	slli	a5,a5,0xc
   106f6:	97ba                	add	a5,a5,a4
   106f8:	43dc                	lw	a5,4(a5)
   106fa:	2781                	sext.w	a5,a5
}
   106fc:	853e                	mv	a0,a5
   106fe:	7422                	ld	s0,40(sp)
   10700:	6145                	addi	sp,sp,48
   10702:	8082                	ret

0000000000010704 <plic_complete>:

void plic_complete(int ctxid, int irqid) {
   10704:	7179                	addi	sp,sp,-48
   10706:	f422                	sd	s0,40(sp)
   10708:	1800                	addi	s0,sp,48
   1070a:	87aa                	mv	a5,a0
   1070c:	872e                	mv	a4,a1
   1070e:	fcf42e23          	sw	a5,-36(s0)
   10712:	87ba                	mv	a5,a4
   10714:	fcf42c23          	sw	a5,-40(s0)
    plic_map *p = (plic_map *)ADDR_BUS0_XSLV_PLIC;
   10718:	0c0007b7          	lui	a5,0xc000
   1071c:	fef43423          	sd	a5,-24(s0)
    p->ctx_prio[ctxid].claim_complete = irqid;
   10720:	fd842703          	lw	a4,-40(s0)
   10724:	fe843683          	ld	a3,-24(s0)
   10728:	fdc42783          	lw	a5,-36(s0)
   1072c:	20078793          	addi	a5,a5,512 # c000200 <_end+0xbfef814>
   10730:	07b2                	slli	a5,a5,0xc
   10732:	97b6                	add	a5,a5,a3
   10734:	c3d8                	sw	a4,4(a5)
}
   10736:	0001                	nop
   10738:	7422                	ld	s0,40(sp)
   1073a:	6145                	addi	sp,sp,48
   1073c:	8082                	ret

000000000001073e <interrupt_handler_c>:


long interrupt_handler_c(long cause, long epc, long long regs[32]) {
   1073e:	7139                	addi	sp,sp,-64
   10740:	fc06                	sd	ra,56(sp)
   10742:	f822                	sd	s0,48(sp)
   10744:	0080                	addi	s0,sp,64
   10746:	fca43c23          	sd	a0,-40(s0)
   1074a:	fcb43823          	sd	a1,-48(s0)
   1074e:	fcc43423          	sd	a2,-56(s0)
     *
     * Rise interrupt from the software maybe done sending a self-IPI:
     *      csrwi mipi, 0
     */
    csr_mcause_type mcause;
    mcause.value = cause;
   10752:	fd843783          	ld	a5,-40(s0)
   10756:	fef43023          	sd	a5,-32(s0)

    if (mcause.bits.irq == 0x1 && mcause.bits.code == 11) {
   1075a:	fe744783          	lbu	a5,-25(s0)
   1075e:	f807f793          	andi	a5,a5,-128
   10762:	0ff7f793          	andi	a5,a5,255
   10766:	cb85                	beqz	a5,10796 <interrupt_handler_c+0x58>
   10768:	fe043703          	ld	a4,-32(s0)
   1076c:	57fd                	li	a5,-1
   1076e:	8385                	srli	a5,a5,0x1
   10770:	8f7d                	and	a4,a4,a5
   10772:	47ad                	li	a5,11
   10774:	02f71163          	bne	a4,a5,10796 <interrupt_handler_c+0x58>
        // External M-Mode
        uint32_t irqid = plic_claim(0);
   10778:	4501                	li	a0,0
   1077a:	f5bff0ef          	jal	ra,106d4 <plic_claim>
   1077e:	87aa                	mv	a5,a0
   10780:	fef42623          	sw	a5,-20(s0)
        plic_complete(0, irqid);
   10784:	fec42783          	lw	a5,-20(s0)
   10788:	85be                	mv	a1,a5
   1078a:	4501                	li	a0,0
   1078c:	00000097          	auipc	ra,0x0
   10790:	f78080e7          	jalr	-136(ra) # 10704 <plic_complete>
    if (mcause.bits.irq == 0x1 && mcause.bits.code == 11) {
   10794:	a029                	j	1079e <interrupt_handler_c+0x60>
    } else {
        fatal_error();
   10796:	00000097          	auipc	ra,0x0
   1079a:	f18080e7          	jalr	-232(ra) # 106ae <fatal_error>
    }

    return epc;
   1079e:	fd043783          	ld	a5,-48(s0)
}
   107a2:	853e                	mv	a0,a5
   107a4:	70e2                	ld	ra,56(sp)
   107a6:	7442                	ld	s0,48(sp)
   107a8:	6121                	addi	sp,sp,64
   107aa:	8082                	ret

00000000000107ac <memcpy>:
   107ac:	00a5c7b3          	xor	a5,a1,a0
   107b0:	8b9d                	andi	a5,a5,7
   107b2:	00c50733          	add	a4,a0,a2
   107b6:	e781                	bnez	a5,107be <memcpy+0x12>
   107b8:	479d                	li	a5,7
   107ba:	00c7ef63          	bltu	a5,a2,107d8 <memcpy+0x2c>
   107be:	87aa                	mv	a5,a0
   107c0:	00e56963          	bltu	a0,a4,107d2 <memcpy+0x26>
   107c4:	8082                	ret
   107c6:	0005c683          	lbu	a3,0(a1) # 1000 <_start-0xf000>
   107ca:	0785                	addi	a5,a5,1
   107cc:	0585                	addi	a1,a1,1
   107ce:	fed78fa3          	sb	a3,-1(a5)
   107d2:	fee7eae3          	bltu	a5,a4,107c6 <memcpy+0x1a>
   107d6:	8082                	ret
   107d8:	00757793          	andi	a5,a0,7
   107dc:	ebbd                	bnez	a5,10852 <memcpy+0xa6>
   107de:	87aa                	mv	a5,a0
   107e0:	ff877693          	andi	a3,a4,-8
   107e4:	fc068613          	addi	a2,a3,-64
   107e8:	06c7fc63          	bleu	a2,a5,10860 <memcpy+0xb4>
   107ec:	0005b383          	ld	t2,0(a1)
   107f0:	0085b283          	ld	t0,8(a1)
   107f4:	0105bf83          	ld	t6,16(a1)
   107f8:	0185bf03          	ld	t5,24(a1)
   107fc:	0205be83          	ld	t4,32(a1)
   10800:	0285be03          	ld	t3,40(a1)
   10804:	0305b303          	ld	t1,48(a1)
   10808:	0385b883          	ld	a7,56(a1)
   1080c:	04858593          	addi	a1,a1,72
   10810:	04878793          	addi	a5,a5,72
   10814:	ff85b803          	ld	a6,-8(a1)
   10818:	fa77bc23          	sd	t2,-72(a5)
   1081c:	fc57b023          	sd	t0,-64(a5)
   10820:	fdf7b423          	sd	t6,-56(a5)
   10824:	fde7b823          	sd	t5,-48(a5)
   10828:	fdd7bc23          	sd	t4,-40(a5)
   1082c:	ffc7b023          	sd	t3,-32(a5)
   10830:	fe67b423          	sd	t1,-24(a5)
   10834:	ff17b823          	sd	a7,-16(a5)
   10838:	ff07bc23          	sd	a6,-8(a5)
   1083c:	b775                	j	107e8 <memcpy+0x3c>
   1083e:	0005c683          	lbu	a3,0(a1)
   10842:	0785                	addi	a5,a5,1
   10844:	0585                	addi	a1,a1,1
   10846:	fed78fa3          	sb	a3,-1(a5)
   1084a:	0077f693          	andi	a3,a5,7
   1084e:	fae5                	bnez	a3,1083e <memcpy+0x92>
   10850:	bf41                	j	107e0 <memcpy+0x34>
   10852:	87aa                	mv	a5,a0
   10854:	bfdd                	j	1084a <memcpy+0x9e>
   10856:	6190                	ld	a2,0(a1)
   10858:	07a1                	addi	a5,a5,8
   1085a:	05a1                	addi	a1,a1,8
   1085c:	fec7bc23          	sd	a2,-8(a5)
   10860:	fed7ebe3          	bltu	a5,a3,10856 <memcpy+0xaa>
   10864:	f6e7e7e3          	bltu	a5,a4,107d2 <memcpy+0x26>
   10868:	8082                	ret
	...
